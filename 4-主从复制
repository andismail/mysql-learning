MySQL复制功能:
	MySQL的复制功能是构建大规模高可用应用的基础
	因为MySQL事务的特性决定了它不能通过其简单的增加服务器解决负载，而MySQL复制功能为提供了分担读负载的办法
	复制功能可以对数据库进行水平扩展，为其增加一个或多个备库，这些备库可以用来分担主数据库的读负载
	复制功能也为高可用、灾难恢复、备份提供了更多的选择
	MySQL上的复制是基于主库上的二进制日志，在备库上重放这些二进制日志完成的,也就意味着在同一时间点可能存在数据不一致同时无法保证主库与备库间的延迟

MySQL复制解决了什么问题:
	1.实现在不同服务器上的数据分布
		利用二进制日志增量进行
		不需要太多的带宽
		但是使用基于行的复制在进行大批量的更改时会对带宽带来一定压力(所以大指修改应该分批进行)
	2.实现数据读取的负载均衡
		需要其它组件配合完成
		利用DNS轮询的方式把程序的读连接到不同的备份数据库
		使用LVS、haproxy这样的代理方式
		非共享架构,同样的数据分布在多台服务器上，所以增加了数据的安全性
		利用备库的备份来减少主库负载
		复制并不能代替备份
		方便进行数据高可用架构的部署，避免MySQL单点失败
	3.实现数据库高可用和故障切换
	4.实现数据库在线升级

日志:
	MySQL服务层日志:二进制日志、慢查日志、通用日志
	MySQL存储引擎层日志-Innodb:重做日志、回滚日志
二进制日志:
	记录了所有对MySQL数据库的修改事件，包括增删改(查?)事件和对表结构的修改事件
	其中记录了的是所有已经执行成功了的，回滚了的或其它原因如语法错误等并未成功执行的事件是不会记录在其中的
二进制日志的格式:
	mysql> show variables like 'binlog_format';
	+---------------+-------+
	| Variable_name | Value |
	+---------------+-------+
	| binlog_format | ROW   |
	+---------------+-------+
	-- 5.7版本默认
	set session binlog_format='statement';-- 设置为段格式
	flush logs; -- 刷新log
	1.基于段的二进制格式 binlog_format=STATEMENT,5.7之前默认使用的格式
		优点:日志记录量相对小，节约磁盘及网络IO，直接记录执行的SQL语句
		缺点:由于其记录的是SQL语句，所以必须记录上下文信息，从而保证语句在从服务器上执行结果和在主服务器上相同
		     一些特定函数如UUID()、user()这样的非确定性函数是无法复制的，可能会造成主从服务器数据不一致
	2.基于行的日志格式 binlog_format=ROW ,ROW格式可以避免MySQL复制中出现的主从不一致问题,每修改一行就会有一条记录,例如修改了1000条数据STATEMENT
	只会记录修改的SQL语句，ROW则会记录这1000条修改了什么
		优点:a.获得更加安全的复制环境 b.只对于条数据修改比基于段的复制高效 c.ROW格式中详细的记录了对每一行数据的修改，所以当误操作修改了数据
			时同时又没有备份可以恢复，此时可以通过分析ROW格式的二进制日志来达到恢复数据的目的
		缺点:记录日志量大，但由于其是顺序写入虽然量大但对磁盘IO影响不太大
		mysql> show variables like '%image%';-- ROW格式的记录方式，FULL:即使更新一列也把其它没更新的记下 MINIMAL:只记录修改的 noblob:
		+------------------+-------+
		| Variable_name    | Value |
		+------------------+-------+
		| binlog_row_image | FULL  |
		+------------------+-------+
		查看:命令行-mysqlbinlog mysql-bin.000004(这种看不懂)	mysqlbinlog -vv mysql-bin.000004 | more (可读懂)
	3.混合日志格式 binlog_format=MIXED ,基于前两者,可以根据SQL语句由系统决定在基于段和行的日志格式中进行选择，数据量大小由所执行的SQL语句决定
	4.建议使用ROW MINIMAL格式日志
