影响数据库性能的几个方面:
	1.服务器硬件
	2.服务器系统
	3.数据库存储引擎选择
	4.数据库参数配置
	5.数据库结构设计和SQL语句


什么是事务:
	1.事务是关系形数据库区别于其它一切文件系统的重要特性之一
	2.事务是一组具有原子性的SQL语句


事务:
	1.原子性:一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败,对于一个事务来说,不可能只执行其中
		 一部分操作
	2.一致性:事务将数据库从一种一致性状态转换到另一种一致性状态,在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏
	3.隔离性:隔离性要求一个事务对数据库中数据的修改,在未提交完成前对于其它事务是不可见的
	4.持久性:一旦事务提交,则其所做的修改就会永久保存到数据库中。此时即使数据系统崩溃,已经提交的修改数据也不会丢失。


事务的隔离性:
	mysql> SHOW VARIABLES LIKE '%ISO%';
	+---------------+-----------------+
	| Variable_name | Value           |
	+---------------+-----------------+
	| tx_isolation  | REPEATABLE-READ |
	+---------------+-----------------+
	--MySQL默认隔离级别
	1.未提交读(READ UNCOMMITED):一个事务中的事务没提交,在其它事务中也可以读到,也就是说的脏读
	2.已提交读(READ COMMITED,不可重复读):
		mysql> SET SESSION tx_isolation='READ-COMMITTED';
		两个未提交的事务间彼此是看不到对方数据处理情况
		若其中有一个提交后,则在另一个事务中就可以看到提交的数据
		同一事务中两次读结果是不一样的
	3.可重复读(REPEATABLE READ, 默认):
		同一个事务中多次读取的结果是一致的
		若两个事务,事务A对表进行了查询操作得到一个结果A_1,事务B对表进行更新或插入操作(无论事务B是否已提交),事务A对表再进行查询得到的结果还是A_1
		(可重复与不可重复指的是同一事务中重复读时的结果不是一至的)
	4.可串行化(SERIALIZABLE)


大事务:
	运行时间较长,操作数据较多的事务(例如:余额宝,计算收益,更新余额等会涉及到大量用户)
	风险:
		锁定太多的数据,造成大量的阻塞和锁超时
		回滚所需时间比较长
		执行时间长,容易造成主从延迟
	处理:
		避免一次性处理太多的数据,可以分批次处理
		事务操作中不要加入其它不必的要操作,例如在事务中夹杂SELECT或其它可能耗时且没必要放在此事务中的操作

为了减少事务提交时的IO开销,事务提交时会先写入事务日志中,而不是每次都把修改的数据刷新到事务文件中

主从同步:主库上事务执行完成后并把日志写入到bin-log中,这时从服务器从通过bin-log进行数据同步


MySQL体系结构
	MySQL服务层:连接管理器、查询缓存、查询解析、查询优化器
	存储引擎层:存储引擎是针对于表的而不是针对于库的(一个库中的不同表可以使用不同的存储引擎),但并不建议这样使用


MyISAM:
	1.MySQL5.5之前版本默认存储引擎
	2.MySQL系统表、临时表在使用这个引擎(临时表是指:在排序、分组等操作中,当数量超过一定的大小之后,由查询优化器建立的临时表)
	3.MyISAM存储引擎表在文件系统中由MYD(数据文件)和MYI(索引文件)组成。(table_name.frm是用来记录表结构的文件并非其特有)
	4.特性:
		锁级别:表级锁,即,在对表中的数据进行修改时会对整个表进行加锁,在对表中数据进行读时要加共享锁(共享锁并不会阻塞共享锁)
		并发性:对有查询和修改的表其表现的并不好
		表损坏修复:check table table_name; repair table table_name;
		表支持数据压缩,命令行:myisampack
	5.限制:
		5.0之前默认表大小为4G,如存储大表则要修改MAX_Rows和AVG_ROW_LENGTH
		5.0之后默认单表支持256TB
	6.使用场景:
		1.非事务型应用
		2.只读类应用
		3.空间应用(GPS,支持空间函数)
		4.全文索引


什么是锁:锁是数据库系统区别于文件系统的重要特性
	主要作用是管理共享资源的并发访问
	实现事务的隔离性

锁的类型:对于Innodb来说读锁和写锁都是行级锁,所谓的读锁和写锁的兼容性指的也是对同一行的兼容性
	共享锁(读锁,相互间不会阻塞,多个线程可以在同一时间读取同一资源,而不相互干扰)
	独占锁(写锁,排它的,会阻塞其它的读锁和写锁,这也是出于对数据完整性的考虑,也就是实现事务的隔离性)
	注意！注意！注意！虽然说写锁与读锁互斥,但实际上,把一条记录加上独占锁(例如开启事务->更新这条记录->不提交事务),
	这时在另一个事务中去查询这条记录是不会被阻塞的,查到的是更新前的记录,实际上查到的结果是Undo Log中的,原因是其锁机制是有些复杂的

锁的粒度:锁的资源越少,系统的并发程度越高
	表级锁:lock table table_name wirte;  unlock tables; MySQL服务器级别实现
	行级锁:可以最大程度支持并发,同时锁的开销要比innodb的大,
	列级锁:MySQL不支持

阻塞和死锁:
	阻塞:一个事务中的锁需要等待另一个事务中的锁释放,可能会使数据库连接大量的堆积而占用大量的系统资源
	死锁:多个事务相互等待锁,例如事务一先更新A记录,事务二先更新B记录,这时事务一再更新B记录(阻塞),事务二再更新A记录(阻塞),两个事务相互等待.
	     数据库系统会自动发现死锁并且在多个死锁的事务中选择一个资源占用最少的事务来进行回滚操作从而使其它事务正常运行

Innodb:
	MySQL5.5及之后成为默认存储引擎
	表中数据存储在自己的表空间中,innodb_file_per_table,
	mysql> SHOW VARIABLES LIKE 'innodb_file_per_table';
	+-----------------------+-------+
	| Variable_name         | Value |
	+-----------------------+-------+
	| innodb_file_per_table | ON    |
	+-----------------------+-------+
	--ON:独立表空间:table_name.idb,OFF:系统表空间:ibdataX(X为数字)
	Innodb系统表空间和独立表空间如何选择:Innodb独立表空间比系统表空间好
	Innodb是一种事务性存储引擎
	完全支持事务的ACID特性
	原子性,一致性,持久性由Redo Log和Undo Log实现,隔离性是由锁实现
	Redo Log:实现事务的持久性,存储的是已提交的事务,具体由内存中的重做日志缓冲区(innodb_log_buffer_size)和
	磁盘上的重做日志文件(innodb_log_files_in_group)组成,Redo Log是顺序写入的。
	mysql> SHOW VARIABLES LIKE 'innodb_log_buffer_size';
	+------------------------+----------+
	| Variable_name          | Value    |
	+------------------------+----------+
	| innodb_log_buffer_size | 16777216 |
	+------------------------+----------+
	-- 单位字节,因为每隔1秒会把缓冲刷新到磁盘上所以不用设置太大。
	mysql> SHOW VARIABLES LIKE 'innodb_log_files_in_group';
	+---------------------------+-------+
	| Variable_name             | Value |
	+---------------------------+-------+
	| innodb_log_files_in_group | 2     |
	+---------------------------+-------+
	-- ib_logfile0,ib_logfile1共两个文件

	Undo Log:存储的是未提交的事务,帮助未提交事务进行回滚和实现MVCC(多版本控制),rollback会用到此日志中的信息,
	是随机读写的,所以把其存储在SSD上会获得更好的性能。
	所以我们对表中的数据修改时会产生Redo log和Undo Log
	Innodb支持行级锁,可以最大程度上的支持并发,行级锁是在存储引擎层实现的
	Innodb状态检查:SHOW ENGINE innodb STATUS;
	适用场景:适用于大多数OLTP应用(5.7版本支持全文索引和空间函数)

不常用存储引擎:
	CSV:可以把CSV文件当成表来存储,不支持索引,所有列必须不能为NULL,不适合OLTP系统,可以对数据文件直接编辑(编辑后flush tables;)
		适用场景:数据交互中间表,例如:|电子表格|->|CSV文件|->|MySQL数据目录|,|数据|->|CSV文件|->|其它Web程序|
	Archive:以zlib对表数据进行压缩,减少磁盘IO,减少磁盘空间(所有引擎中最小),只支持SELECT和INSERT操作,只支持在自增ID上建索引,不支持事务
		适用场景:日志和数据采集类应用
	Memory:也称HEAP存储引擎,所有数据保存在内存中,所有字段固定长度,不支持BLOG和TEXT等大字段类型,表级锁,表大小由max_heap_table_size决定
		使用场景:Memory数据易丢失,所以要求数据可再生,个人觉得慎用
	Federated:提供了访问远程MySQL服务器上表的方法,本地并不存储数据数据全部放到远程服务器上,本地需要保存表结构和远程服务器的连接信息
		此引擎默认禁止,启用需要在启动时增加federated参数
		使用场景:偶尔的统计分析及手工查询
如何选择正确存储引擎:
	1.事务
	2.备份,mysqldump会加锁,所以并不能算是热备方案
	3.崩溃恢复
	建议不要混合使用存储引擎,把原本不那么复杂的东西搞的复杂但带来的提升确不明显

MySQL服务器参数
	1.命令行参数
		mysqld_safe --datadir=/data/sql_data
	2.配置文件
		显示配置文件加载顺序:mysqld --help --verbose | grep -A 1 'Default options'
	3.MySQL配置参数作用域
		全局参数:set global 参数名=参数值;或 set @@global.参数名:=参数值;
		会话参数:set [session] 参数名=参数值;或 set @@session.参数名:=参数值; 
	4.内存配置相关参数
		连接数越大占用的内存越多
	5.安全相关配置参数
		expire_logs_days 指定自动清理binlog的天数
		max_allowed_packet控制MySQL可以接收的包大小
		skip_name_resolve禁用DNS查找
		sysdate_is_now确保sysdate()返回正确性日期
		read_only禁止非super权限的用户写权限
		skip_slave_start禁用Slave自动恢复
		sql_mode设置MySQL所使用的SQL模式(即常见的group by查询的字段可以不全部出现在条件中)
	6.其它常用配置参数
		sync_binlog控制MySQL如何向磁盘刷新binlog
		tmp_table_size和max_heap_table_size控制内存临时表大小
		max_connections控制允许的最大连接数

数据库设计对性能的影响
	1.过分的反范式化为表建立太多的列
	2.过分的范式化造成太多的表关联
	3.外键约束

MySQL服务器!服务器!服务器!性能优化顺序
	1.数据库结构设计和SQL语句,如表结果,索引
	2.数据库存储引擎的选择和参数配置
	3.系统选择及优化
	4.硬件升级
